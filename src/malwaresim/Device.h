/**
 * Device classes.
 *
 * Copyright (c) 2004-7 David R.Cheriton, All rights reserved.
 *
 * Edited by Mark Linton for CS 249A Fall 2014.
 */

#ifndef DEVICE_H
#define DEVICE_H

#include <vector>
#include <list>

#include <iostream>

using fwk::BaseNotifiee;
using fwk::NamedInterface;
using fwk::NotifierLib::post;
using fwk::Ptr;

class Network;

/**
 * Device is an abstract base class with a name (defined in NamedInterface),
 * a containing network, and a collection of ports numbered from 0 to portCount.
 */
class Device : public NamedInterface {
public:

    class Notifiee : public BaseNotifiee<Device> {
    public:

        void notifierIs(const Ptr<Device>& notifier) {
            connect(notifier, this);
        }


        /** Notification that the device's health changed. */
        virtual void onHealth() { }

        /** Notification that a port on the device changed. */
        virtual void onPort(const U32 n) { }

        /** Notification that the device's network changed. */
        virtual void onNetwork() { }

    };


    /** Network containing this device. */
    Network* network() {
        return network_;
    }


    /** Current health of the device. */
    const string& health() {
        return health_;
    }

    /** Modify the health of this device. */
    void healthIs(const string& health) {
        if (health_ != health) {
            if (health != "healthy" && health != "infected") {
                throw std::invalid_argument(health);
            }

            health_ = health;

            post(this, &Notifiee::onHealth);
        }
    }

protected:

    typedef std::vector<Port> PortVector;

    typedef std::list<Notifiee*> NotifieeList;

public:

    typedef PortVector::size_type size_type;


    /** Number of ports on the device. */
    size_type portCount() {
        return ports_.size();
    }


    /** Collection of ports on the device for range-based iteration. */
    const PortVector& ports() {
        return ports_;
    }

    /** Information for a specific port. */
    const Port& port(const U32 p) {
        return ports_[p];
    }


    /** Anti-malware rating of a specific port. */
    const MalwareStrength portRating(const U32 p) {
        return ports_[p].rating();
    }

    /** Modify the anti-malware rating of a specific port. */
    _noinline
    void portRatingIs(const U32 p, const MalwareStrength& rating) {
        Port& port = ports_[p];
        if (port.rating() != rating) {
            ports_[p].ratingIs(rating);

            post(this, &Notifiee::onPort, p);
        }
    }


    /**
     * Flag indicating whether a specific port is not connected to any device.
     */
    bool availablePort(const U32 p) {
        return ports_[p].otherDevice() == null;
    }

    /**
     * Modify the flag indicating that a specific port is not connected
     * to any device. If the port is connected to a device then
     * this operation will disconnect it and generate onPort notifications
     * both for this device and the connected device.
     */
    void availablePortIsTrue(const U32 p) {
        auto& port = ports_[p];
        const auto otherDevice = port.otherDevice();

        if (otherDevice != null) {
            const auto p2 = port.otherPort();

            port.connectionIs(null, 0);
            otherDevice->ports_[p2].connectionIs(null, 0);

            post(this, &Notifiee::onPort, p);
            post(otherDevice.ptr(), &Notifiee::onPort, p2);
        }
    }


    /**
     * The device to which a specific port is connected or null
     * if the port is available.
     */
    const Ptr<Device>& otherDevice(const U32 p) {
        return ports_[p].otherDevice();
    }

    /**
     * The other device's port that is connected to this device on
     * the specified port.
     */
    U32 otherPort(const U32 p) {
        return ports_[p].otherPort();
    }

    /**
     * Connect a given port to given device and device's port.
     *
     * This operation modifies the port information for BOTH this device and
     * the given device, as well as posting notfications for both updates.
     *
     * If this device's port is already connected to another device then
     * we must disconnect and update that device. Similarly, if the given
     * device is already connected to a device on the given port then
     * we must disconnect and update that connected device.
     *
     * So this operation can update four devices if we connect A to B with
     * A currently connected to C and B currently connected to D.
     */
    _noinline
    void connectionIs(
        const U32 p, const Ptr<Device>& device, const U32 devicePort
    ) {
        auto& port = ports_[p];
        auto& otherPort = device->ports_[devicePort];

        if (port.otherDevice() == device && otherPort.otherDevice() == this) {
            // Ignore if connection already exists.
            return;
        }

        // Save connection info (must be a copy).
        const auto oldConnection = port;
        const auto otherOldConnection = otherPort;

        // Disconnect the previously-attached device, if any.
        const auto& oldDevice = oldConnection.otherDevice();
        if (oldDevice != null) {
            const auto p2 = oldConnection.otherPort();
            oldDevice->ports_[p2].connectionIs(null, 0);

            post(oldDevice.ptr(), &Notifiee::onPort, p2);
        }

        // Disconnect the other previously-attached device, if any.
        const auto& otherOldDevice = otherOldConnection.otherDevice();
        if (otherOldDevice != null) {
            const auto p2 = otherOldConnection.otherPort();
            otherOldDevice->ports_[p2].connectionIs(null, 0);

            post(otherOldDevice.ptr(), &Notifiee::onPort, p2);
        }

        // Update both ports in place.
        port.connectionIs(device, devicePort);
        otherPort.connectionIs(this, p);

        // Post notifications for both ports.
        post(this, &Notifiee::onPort, p);
        post(device.ptr(), &Notifiee::onPort, devicePort);
    }


    /**
     * Collection of notifiees.
     */
    NotifieeList& notifiees() {
        return notifiees_;
    }


    /** Devices are entity types and may not be copied. */
    Device(const Device&) = delete;

    /** Devices are entity types and may not be copied. */
    void operator =(const Device&) = delete;

protected:

    // For setting (clearing, really) the network_ member.
    friend class Network;


    Network* network_;

    PortVector ports_;

    string health_;

    NotifieeList notifiees_;


    _noinline
    Device(const string& name, const U32 n, const MalwareStrength rating) :
        NamedInterface(name),
        network_(null),
        ports_(n),
        health_("healthy")
    {
        for (auto& port : ports_) {
            port.ratingIs(rating);
        }
    }

    ~Device() {
        const auto n = portCount();
        for (U32 p = 0; p < n; ++p) {
            availablePortIsTrue(p);
        }

        network_ = null;
    }


    void networkIs(Network* const network) {
        if (network != network_) {
            network_ = network;

            post(this, &Notifiee::onNetwork);
        }
    }

};


/**
 * PersonalDevice is a subclass for devices that have individual users,
 * in contrast to server or network devices.
 */
class PersonalDevice : public Device {
public:

    /**
     * Return a new instance with the given name.
     */
    static Ptr<PersonalDevice> instanceNew(const string& name) {
        return new PersonalDevice(name);
    }

protected:

    static const U32 defaultPortCount = 8;

    static constexpr double defaultRating = 0.0;


    PersonalDevice(const string& name) :
        Device(name, defaultPortCount, defaultRating)
    {
        // Nothing else to do.
    }

    PersonalDevice(
        const string& name, const U32 portCount, const MalwareStrength rating
    ) :
        Device(name, portCount, rating)
    {
        // Nothing else to do.
    }

};

/**
 * MobileDevice is a subclass for personal devices that are likely
 * to change location while connected to a network.
 */
class MobileDevice : public PersonalDevice {
public:

    /**
     * Return a new instance with the given name.
     */
    static Ptr<MobileDevice> instanceNew(const string& name) {
        return new MobileDevice(name);
    }

protected:

    static constexpr double defaultRating = 0.9;


    MobileDevice(const string& name) :
        PersonalDevice(name, defaultPortCount, defaultRating)
    {
        // Nothing else to do.
    }

};

/**
 * NetworkDevice is an abstract subclass for devices
 * that route and/or manage traffic in a network.
 */
class NetworkDevice : public Device {
protected:

    static const U32 defaultPortCount = 16;

    static constexpr double defaultRating = 0.0;


    NetworkDevice(const string& name) :
        Device(name, defaultPortCount, defaultRating)
    {
        // Nothing else to do.
    }

    NetworkDevice(
        const string& name, const U32 portCount, const MalwareStrength rating
    ) :
        Device(name, portCount, rating)
    {
        // Nothing else to do.
    }

};

class FirewallDevice : public NetworkDevice {
public:

    /**
     * Return a new instance with the given name.
     */
    static Ptr<FirewallDevice> instanceNew(const string& name) {
        return new FirewallDevice(name);
    }

protected:

    static constexpr double defaultRating = 1.0;


    FirewallDevice(const string& name) :
        NetworkDevice(name, defaultPortCount, defaultRating)
    {
        // Nothing else to do.
    }

};

#endif
